From 8485a6b10e1590f6719ce4da66ea5e64162ab5e5 Mon Sep 17 00:00:00 2001
From: Thorsten Kummermehr <thorsten.kummermehr@k2l.de>
Date: Mon, 20 Nov 2017 10:43:21 +0100
Subject: [PATCH 1/2] Use libxml2 instead of mxml

Signed-off-by: Thorsten Kummermehr <thorsten.kummermehr@k2l.de>
---
 3rdparty/CMakeLists.txt         |  42 --------
 ucs2-interface/CMakeLists.txt   |  10 +-
 ucs2-interface/ucs-xml/UcsXml.c | 229 +++++++++++++++++++---------------------
 3 files changed, 114 insertions(+), 167 deletions(-)
 delete mode 100644 3rdparty/CMakeLists.txt

diff --git a/3rdparty/CMakeLists.txt b/3rdparty/CMakeLists.txt
deleted file mode 100644
index ba0f803..0000000
--- a/3rdparty/CMakeLists.txt
+++ /dev/null
@@ -1,42 +0,0 @@
-###########################################################################
-# Copyright 2015, 2016, 2017 IoT.bzh
-#
-# author: Fulup Ar Foll <fulup@iot.bzh>
-#
-# Licensed under the Apache License, Version 2.0 (the "License");
-# you may not use this file except in compliance with the License.
-# You may obtain a copy of the License at
-#
-#     http://www.apache.org/licenses/LICENSE-2.0
-#
-# Unless required by applicable law or agreed to in writing, software
-# distributed under the License is distributed on an "AS IS" BASIS,
-# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-# See the License for the specific language governing permissions and
-# limitations under the License.
-###########################################################################
-
-set(MXML external-mxml)
-set(MXML_SOURCE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/mxml)
-include(${CMAKE_ROOT}/Modules/ExternalProject.cmake)
-ExternalProject_Add(${MXML}
-    GIT_REPOSITORY https://github.com/michaelrsweet/mxml.git
-    GIT_TAG release-2.10
-    SOURCE_DIR ${MXML_SOURCE_DIR}
-    CONFIGURE_COMMAND ./configure --build x86_64 --host aarch64
-    BUILD_COMMAND make libmxml.so.1.5
-    BUILD_IN_SOURCE 1
-    INSTALL_COMMAND ""
-)
-
-PROJECT_TARGET_ADD(mxml)
-
-add_library(${TARGET_NAME} SHARED IMPORTED GLOBAL)
-
-SET_TARGET_PROPERTIES(${TARGET_NAME} PROPERTIES
-    LABELS LIBRARY
-    IMPORTED_LOCATION ${MXML_SOURCE_DIR}/libmxml.so.1
-    INTERFACE_INCLUDE_DIRECTORIES ${MXML_SOURCE_DIR}
-)
-
-add_dependencies(${TARGET_NAME} ${MXML})
diff --git a/ucs2-interface/CMakeLists.txt b/ucs2-interface/CMakeLists.txt
index 8cd797c..8d71268 100644
--- a/ucs2-interface/CMakeLists.txt
+++ b/ucs2-interface/CMakeLists.txt
@@ -20,17 +20,19 @@
 PROJECT_TARGET_ADD(ucs2-inter)
     set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -DNDEBUG")
 
-    # Define targets
+	# Search for libs
+	find_package (LibXml2 REQUIRED)
+    
+	# Define targets
     ADD_LIBRARY(ucs2-inter STATIC ucs_lib_interf.c ucs-xml/UcsXml.c ucs-xml/UcsXml_Private.c)
 
     # Library properties
     SET_TARGET_PROPERTIES(ucs2-inter PROPERTIES OUTPUT_NAME ucs2interface)
 
     # Depends on Unicens2 lib
-    TARGET_LINK_LIBRARIES(ucs2-inter ucs2-lib mxml)
+    TARGET_LINK_LIBRARIES(ucs2-inter ucs2-lib ${LIBXML2_LIBRARIES})
 
     # Define includes
     TARGET_INCLUDE_DIRECTORIES(ucs2-inter
-        PUBLIC  ${CMAKE_CURRENT_SOURCE_DIR}
-        INTERFACE mxml
+        PUBLIC  ${CMAKE_CURRENT_SOURCE_DIR} ${LIBXML2_INCLUDE_DIR}
     )
diff --git a/ucs2-interface/ucs-xml/UcsXml.c b/ucs2-interface/ucs-xml/UcsXml.c
index 4c392cd..f61aea1 100644
--- a/ucs2-interface/ucs-xml/UcsXml.c
+++ b/ucs2-interface/ucs-xml/UcsXml.c
@@ -29,7 +29,8 @@
 /*------------------------------------------------------------------------------------------------*/
 #include <assert.h>
 #include <string.h>
-#include "mxml.h"
+#include <libxml/tree.h>
+#include <libxml/parser.h>
 #include "UcsXml_Private.h"
 #include "UcsXml.h"
 
@@ -105,7 +106,7 @@ typedef struct
     Ucs_Xrm_ResObject_t *outSocket;
     struct UcsXmlJobList *jobList;
     Ucs_Xrm_Combiner_t *combiner;
-    mxml_node_t *pendingCombinerMostSockets;
+    xmlNode *pendingCombinerMostSockets;
     Ucs_Sync_MuteMode_t muteMode;
     Ucs_Avp_IsocPacketSize_t isocPacketSize;
 } ConnectionData_t;
@@ -116,6 +117,7 @@ typedef struct
 } ScriptData_t;
 
 typedef struct {
+    xmlDoc *root;
     uint16_t autoRouteId;
     struct UcsXmlObjectList objList;
     struct UcsXmlRoute *pRtLst;
@@ -227,36 +229,36 @@ static const char* VALUE_0 =                "0";
 /************************************************************************/
 
 static void FreeVal(UcsXmlVal_t *ucs);
-static bool GetElement(mxml_node_t *element, const char *name, bool goDeep, mxml_node_t **out, bool mandatory);
-static bool GetElementArray(mxml_node_t *element, const char *array[], const char **foundName, mxml_node_t **out);
-static bool GetCount(mxml_node_t *element, const char *name, uint32_t *out, bool mandatory);
-static bool GetCountArray(mxml_node_t *element, const char *array[], uint32_t *out, bool mandatory);
-static bool GetString(mxml_node_t *element, const char *key, const char **out, bool mandatory);
+static bool GetElement(xmlNode *element, const char *name, bool goDeep, xmlNode **out, bool mandatory);
+static bool GetElementArray(xmlNode *element, const char *array[], const char **foundName, xmlNode **out);
+static bool GetCount(xmlNode *element, const char *name, uint32_t *out, bool mandatory);
+static bool GetCountArray(xmlNode *element, const char *array[], uint32_t *out, bool mandatory);
+static bool GetString(xmlNode *element, const char *key, const char **out, bool mandatory);
 static bool CheckInteger(const char *val, bool forceHex);
-static bool GetUInt16(mxml_node_t *element, const char *key, uint16_t *out, bool mandatory);
-static bool GetUInt8(mxml_node_t *element, const char *key, uint8_t *out, bool mandatory);
+static bool GetUInt16(xmlNode *element, const char *key, uint16_t *out, bool mandatory);
+static bool GetUInt8(xmlNode *element, const char *key, uint8_t *out, bool mandatory);
 static bool GetSocketType(const char *txt, MSocketType_t *out);
-static bool GetPayload(mxml_node_t *element, const char *name, uint8_t **pPayload, uint8_t *len, uint8_t offset,
+static bool GetPayload(xmlNode *element, const char *name, uint8_t **pPayload, uint8_t *len, uint8_t offset,
             struct UcsXmlObjectList *obj, bool mandatory);
 static bool AddJob(struct UcsXmlJobList **joblist, Ucs_Xrm_ResObject_t *job, struct UcsXmlObjectList *objList);
 static Ucs_Xrm_ResObject_t **GetJobList(struct UcsXmlJobList *joblist, struct UcsXmlObjectList *objList);
 static struct UcsXmlJobList *DeepCopyJobList(struct UcsXmlJobList *jobsIn, struct UcsXmlObjectList *objList);
 static void AddRoute(struct UcsXmlRoute **pRtLst, struct UcsXmlRoute *route);
 static void AddScript(struct UcsXmlScript **pScrLst, struct UcsXmlScript *script);
-static ParseResult_t ParseAll(mxml_node_t *tree, UcsXmlVal_t *ucs, PrivateData_t *priv);
-static ParseResult_t ParseNode(mxml_node_t * node, PrivateData_t *priv);
-static ParseResult_t ParseConnection(mxml_node_t * node, const char *conType, PrivateData_t *priv);
-static ParseResult_t ParseSocket(mxml_node_t *soc, bool isSource, MSocketType_t socketType, struct UcsXmlJobList **jobList, PrivateData_t *priv);
-static ParseResult_t ParseScript(mxml_node_t *scr, PrivateData_t *priv);
+static ParseResult_t ParseAll(xmlNode * node, UcsXmlVal_t *ucs, PrivateData_t *priv);
+static ParseResult_t ParseNode(xmlNode * node, PrivateData_t *priv);
+static ParseResult_t ParseConnection(xmlNode * node, const char *conType, PrivateData_t *priv);
+static ParseResult_t ParseSocket(xmlNode *soc, bool isSource, MSocketType_t socketType, struct UcsXmlJobList **jobList, PrivateData_t *priv);
+static ParseResult_t ParseScript(xmlNode *scr, PrivateData_t *priv);
 static bool FillScriptInitialValues(Ucs_Ns_Script_t *scr, PrivateData_t *priv);
-static ParseResult_t ParseScriptMsgSend(mxml_node_t *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv);
-static ParseResult_t ParseScriptGpioPortCreate(mxml_node_t *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv);
-static ParseResult_t ParseScriptGpioPinMode(mxml_node_t *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv);
-static ParseResult_t ParseScriptGpioPinState(mxml_node_t *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv);
-static ParseResult_t ParseScriptPortCreate(mxml_node_t *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv);
-static ParseResult_t ParseScriptPortWrite(mxml_node_t *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv);
-static ParseResult_t ParseScriptPortRead(mxml_node_t *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv);
-static ParseResult_t ParseScriptPause(mxml_node_t *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv);
+static ParseResult_t ParseScriptMsgSend(xmlNode *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv);
+static ParseResult_t ParseScriptGpioPortCreate(xmlNode *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv);
+static ParseResult_t ParseScriptGpioPinMode(xmlNode *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv);
+static ParseResult_t ParseScriptGpioPinState(xmlNode *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv);
+static ParseResult_t ParseScriptPortCreate(xmlNode *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv);
+static ParseResult_t ParseScriptPortWrite(xmlNode *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv);
+static ParseResult_t ParseScriptPortRead(xmlNode *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv);
+static ParseResult_t ParseScriptPause(xmlNode *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv);
 static ParseResult_t ParseRoutes(UcsXmlVal_t *ucs, PrivateData_t *priv);
 
 /************************************************************************/
@@ -265,16 +267,19 @@ static ParseResult_t ParseRoutes(UcsXmlVal_t *ucs, PrivateData_t *priv);
 
 UcsXmlVal_t *UcsXml_Parse(const char *xmlString)
 {
+    xmlDoc *root;
     UcsXmlVal_t *val = NULL;
     ParseResult_t result = Parse_MemoryError;
-    mxml_node_t *tree;
-    if (!(tree = mxmlLoadString(NULL, xmlString, MXML_NO_CALLBACK))) goto ERROR;
-    if (!GetElement(tree, UNICENS, true, &tree, true)) goto ERROR;
+    xmlNode *tree;
+    if (NULL == (root = xmlReadMemory( xmlString, strlen( xmlString ), "config.xml", NULL, 0 ))) goto ERROR;
+    tree = xmlDocGetRootElement(root);
+    if (0 != strcmp(UNICENS, (const char *)tree->name)) goto ERROR;
     /*Do not use MCalloc for the root element*/
     val = calloc(1, sizeof(UcsXmlVal_t));
     if (!val) goto ERROR;
     val->pInternal = calloc(1, sizeof(PrivateData_t));
     if (!val->pInternal) goto ERROR;
+    ((PrivateData_t *)val->pInternal)->root = root;
     result = ParseAll(tree, val, val->pInternal);
     if (Parse_Success == result)
         return val;
@@ -284,8 +289,8 @@ ERROR:
     else
         UcsXml_CB_OnError("XML parsing error, aborting..", 0);
     assert(false);
-    if (!tree)
-        mxmlDelete(tree);
+    if (!root)
+        xmlFreeDoc(root);
     if (val)
         FreeVal(val);
     return NULL;
@@ -307,46 +312,51 @@ void FreeVal(UcsXmlVal_t *ucs)
         return;
     priv = ucs->pInternal;
     FreeObjList(&priv->objList);
+    
+    if (!priv->root)
+        xmlFreeDoc(priv->root);
+    
     free(ucs->pInternal);
     free(ucs);
 }
 
-static bool GetElement(mxml_node_t *element, const char *name, bool goDeep, mxml_node_t **out, bool mandatory)
+static bool GetElement(xmlNode *element, const char *name, bool goDeep, xmlNode **out, bool mandatory)
 {
-    mxml_node_t *n = element;
+    xmlNode *n = element;
     if (NULL == n || NULL == name || NULL == out) return false;
-    if (goDeep)
+    if (goDeep && GetElement(n->children, name, goDeep, out, false))
     {
-        *out = mxmlFindElement(n, n, name, NULL, NULL, MXML_DESCEND);
-        return (NULL != *out);
+        return true;
     }
     while ((n = n->next))
     {
-        if (MXML_ELEMENT != n->type)
+        if (XML_ELEMENT_NODE != n->type)
             continue;
-        if (0 == strcmp(name, n->value.opaque))
+        if (0 == strcmp(name, (const char *)n->name))
         {
             *out = n;
             return true;
         }
+        else if (goDeep && GetElement(n->children, name, goDeep, out, false))
+        {
+            return true;
+        }
     }
     if (mandatory)
         UcsXml_CB_OnError("Can not find tag <%s>", 1, name);
     return false;
 }
 
-static bool GetElementArray(mxml_node_t *element, const char *array[], const char **foundName, mxml_node_t **out)
+static bool GetElementArray(xmlNode *element, const char *array[], const char **foundName, xmlNode **out)
 {
-    mxml_node_t *n = element;
+    xmlNode *n = element;
     if (NULL == n || NULL == array || NULL == foundName || NULL == out) return false;
     while ((n = n->next))
     {
         uint32_t i;
-        if (MXML_ELEMENT != n->type)
-            continue;
         for (i = 0; NULL != array[i]; i++)
         {
-            if (0 == strcmp(array[i], n->value.opaque))
+            if (0 == strcmp(array[i], (const char *)n->name))
             {
                 *foundName = array[i];
                 *out = n;
@@ -357,10 +367,10 @@ static bool GetElementArray(mxml_node_t *element, const char *array[], const cha
     return false;
 }
 
-static bool GetCount(mxml_node_t *element, const char *name, uint32_t *out, bool mandatory)
+static bool GetCount(xmlNode *element, const char *name, uint32_t *out, bool mandatory)
 {
     uint32_t cnt = 0;
-    mxml_node_t *n;
+    xmlNode *n;
     if (NULL == element || NULL == name) return false;
     if(!GetElement(element, name, true, &n, false))
         return false;
@@ -379,11 +389,11 @@ static bool GetCount(mxml_node_t *element, const char *name, uint32_t *out, bool
     return true;
 }
 
-static bool GetCountArray(mxml_node_t *element, const char *array[], uint32_t *out, bool mandatory)
+static bool GetCountArray(xmlNode *element, const char *array[], uint32_t *out, bool mandatory)
 {
     const char *tmp;
     uint32_t cnt = 0;
-    mxml_node_t *n;
+    xmlNode *n;
     if (NULL == element || NULL == array) return false;
     n = element;
     while(NULL != n)
@@ -401,22 +411,32 @@ static bool GetCountArray(mxml_node_t *element, const char *array[], uint32_t *o
     return true;
 }
 
-static bool GetString(mxml_node_t *element, const char *key, const char **out, bool mandatory)
+static bool GetString(xmlNode *element, const char *key, const char **out, bool mandatory)
 {
-    int32_t i;
+    struct _xmlAttr *curAttr;
     if (NULL == element || NULL == key) return false;
-    for (i = 0; i < element->value.element.num_attrs; i++)
+    curAttr = element->properties;
+    do
     {
-        mxml_attr_t *attr = &element->value.element.attrs[i];
-        if (0 == strcmp(key, attr->name))
+        if (XML_ATTRIBUTE_NODE != curAttr->type)
+            continue;
+        if (0 == strcmp(key, (const char *)curAttr->name))
         {
-            *out = attr->value;
-            return true;
+            struct _xmlNode *valAttr = curAttr->children;
+            do
+            {
+                if (XML_TEXT_NODE != valAttr->type)
+                    continue;
+                *out = (const char *)valAttr->content;
+                return true;
+            }
+            while (NULL != (valAttr = valAttr->next));
         }
     }
+    while (NULL != (curAttr = curAttr->next));
     if (mandatory)
         UcsXml_CB_OnError("Can not find attribute='%s' from element <%s>",
-            2, key, element->value.element.name);
+            2, key, element->name);
     return false;
 }
 
@@ -447,7 +467,7 @@ static bool CheckInteger(const char *value, bool forceHex)
     return true;
 }
 
-static bool GetUInt16(mxml_node_t *element, const char *key, uint16_t *out, bool mandatory)
+static bool GetUInt16(xmlNode *element, const char *key, uint16_t *out, bool mandatory)
 {
     long int value;
     const char* txt;
@@ -467,7 +487,7 @@ static bool GetUInt16(mxml_node_t *element, const char *key, uint16_t *out, bool
     return true;
 }
 
-static bool GetUInt8(mxml_node_t *element, const char *key, uint8_t *out, bool mandatory)
+static bool GetUInt8(xmlNode *element, const char *key, uint8_t *out, bool mandatory)
 {
     long int value;
     const char* txt;
@@ -528,7 +548,7 @@ static bool GetSocketType(const char *txt, MSocketType_t *out)
     return true;
 }
 
-static bool GetPayload(mxml_node_t *element, const char *name, uint8_t **pPayload, uint8_t *outLen, uint8_t offset, struct UcsXmlObjectList *obj, bool mandatory)
+static bool GetPayload(xmlNode *element, const char *name, uint8_t **pPayload, uint8_t *outLen, uint8_t offset, struct UcsXmlObjectList *obj, bool mandatory)
 {
     uint32_t tempLen, len = 0;
     uint8_t *p;
@@ -683,10 +703,10 @@ static void AddScript(struct UcsXmlScript **pScrLst, struct UcsXmlScript *script
     tail->next = script;
 }
 
-static ParseResult_t ParseAll(mxml_node_t *tree, UcsXmlVal_t *ucs, PrivateData_t *priv)
+static ParseResult_t ParseAll(xmlNode *tree, UcsXmlVal_t *ucs, PrivateData_t *priv)
 {
     uint32_t nodeCount;
-    mxml_node_t *sub;
+    xmlNode *sub;
     ParseResult_t result;
     priv->autoRouteId = 0x8000;
     if (!GetCount(tree, NODE, &nodeCount, true))
@@ -704,24 +724,24 @@ static ParseResult_t ParseAll(mxml_node_t *tree, UcsXmlVal_t *ucs, PrivateData_t
     while(sub)
     {
         const char *conType;
-        mxml_node_t *con;
+        xmlNode *con;
         memset(&priv->nodeData, 0, sizeof(NodeData_t));
         priv->nodeData.nod = &ucs->pNod[ucs->nodSize];
         if (Parse_Success != (result = ParseNode(sub, priv)))
             return result;
         /*/Iterate all connections. Node without any connection is also valid.*/
-        if (GetElementArray(sub->child, ALL_CONNECTIONS, &conType, &con))
+        if (GetElementArray(sub->children, ALL_CONNECTIONS, &conType, &con))
         {
             while(con)
             {
                 const char *socTypeStr;
                 MSocketType_t socType;
-                mxml_node_t *soc;
+                xmlNode *soc;
                 memset(&priv->conData, 0, sizeof(ConnectionData_t));
                 if (Parse_Success != (result = ParseConnection(con, conType, priv)))
                     return result;
                 /*Iterate all sockets*/
-                if(!GetElementArray(con->child, ALL_SOCKETS, &socTypeStr, &soc)) RETURN_ASSERT(Parse_XmlError);
+                if(!GetElementArray(con->children, ALL_SOCKETS, &socTypeStr, &soc)) RETURN_ASSERT(Parse_XmlError);
                 while(soc)
                 {
                     if (!GetSocketType(socTypeStr, &socType)) RETURN_ASSERT(Parse_XmlError);
@@ -774,10 +794,10 @@ static ParseResult_t ParseAll(mxml_node_t *tree, UcsXmlVal_t *ucs, PrivateData_t
     return result;
 }
 
-static ParseResult_t ParseNode(mxml_node_t *node, PrivateData_t *priv)
+static ParseResult_t ParseNode(xmlNode *node, PrivateData_t *priv)
 {
     const char *txt;
-    mxml_node_t *port;
+    xmlNode *port;
     Ucs_Signature_t *signature;
     assert(NULL != node && NULL != priv);
     priv->nodeData.nod->signature_ptr = MCalloc(&priv->objList, 1, sizeof(Ucs_Signature_t));
@@ -794,7 +814,7 @@ static ParseResult_t ParseNode(mxml_node_t *node, PrivateData_t *priv)
         AddScript(&priv->pScrLst, scr);
     }
     /*Iterate all ports*/
-    if(GetElementArray(node->child, ALL_PORTS, &txt, &port))
+    if(GetElementArray(node->children, ALL_PORTS, &txt, &port))
     {
         while(port)
         {
@@ -838,7 +858,7 @@ static ParseResult_t ParseNode(mxml_node_t *node, PrivateData_t *priv)
     return Parse_Success;;
 }
 
-static ParseResult_t ParseConnection(mxml_node_t * node, const char *conType, PrivateData_t *priv)
+static ParseResult_t ParseConnection(xmlNode * node, const char *conType, PrivateData_t *priv)
 {
     assert(NULL != node && NULL != priv);
     if (NULL == conType) RETURN_ASSERT(Parse_XmlError);
@@ -903,7 +923,7 @@ static ParseResult_t ParseConnection(mxml_node_t * node, const char *conType, Pr
     return Parse_Success;
 }
 
-static ParseResult_t ParseSocket(mxml_node_t *soc, bool isSource, MSocketType_t socketType, struct UcsXmlJobList **jobList, PrivateData_t *priv)
+static ParseResult_t ParseSocket(xmlNode *soc, bool isSource, MSocketType_t socketType, struct UcsXmlJobList **jobList, PrivateData_t *priv)
 {
     Ucs_Xrm_ResObject_t **targetSock;
     assert(NULL != soc && NULL != priv);
@@ -1003,7 +1023,7 @@ static ParseResult_t ParseSocket(mxml_node_t *soc, bool isSource, MSocketType_t
     }
     case MSocket_SPLITTER:
     {
-        mxml_node_t *mostSoc;
+        xmlNode *mostSoc;
         struct SplitterParameters p;
         if (isSource)
         {
@@ -1017,7 +1037,7 @@ static ParseResult_t ParseSocket(mxml_node_t *soc, bool isSource, MSocketType_t
         if (!(p.inSoc = priv->conData.inSocket)) RETURN_ASSERT(Parse_XmlError);
         if (!GetSplitter((Ucs_Xrm_Splitter_t **)&priv->conData.inSocket, &p)) RETURN_ASSERT(Parse_XmlError);
         if (!AddJob(jobList, priv->conData.inSocket, &priv->objList)) RETURN_ASSERT(Parse_XmlError);
-        if (!GetElement(soc->child, MOST_SOCKET, false, &mostSoc, true))
+        if (!GetElement(soc->children, MOST_SOCKET, false, &mostSoc, true))
             RETURN_ASSERT(Parse_XmlError);
         priv->conData.syncOffsetNeeded = true;
 
@@ -1042,7 +1062,7 @@ static ParseResult_t ParseSocket(mxml_node_t *soc, bool isSource, MSocketType_t
         if (!GetUInt16(soc, BYTES_PER_FRAME, &p.bytesPerFrame, true)) RETURN_ASSERT(Parse_XmlError);
         if (!GetCombiner(&priv->conData.combiner, &p)) RETURN_ASSERT(Parse_XmlError);
         priv->conData.syncOffsetNeeded = true;
-        if (!GetElement(soc->child, MOST_SOCKET, false, &priv->conData.pendingCombinerMostSockets, true))
+        if (!GetElement(soc->children, MOST_SOCKET, false, &priv->conData.pendingCombinerMostSockets, true))
             RETURN_ASSERT(Parse_XmlError);
         break;
     }
@@ -1053,7 +1073,7 @@ static ParseResult_t ParseSocket(mxml_node_t *soc, bool isSource, MSocketType_t
     if (NULL != priv->conData.outSocket && NULL != priv->conData.combiner &&
         NULL != priv->conData.pendingCombinerMostSockets)
     {
-        mxml_node_t *tmp = priv->conData.pendingCombinerMostSockets;
+        xmlNode *tmp = priv->conData.pendingCombinerMostSockets;
         priv->conData.pendingCombinerMostSockets = NULL;
         /* Current output socket will be stored inside combiner
          * and combiner will become the new output socket */
@@ -1131,10 +1151,10 @@ static ParseResult_t ParseSocket(mxml_node_t *soc, bool isSource, MSocketType_t
     return Parse_Success;
 }
 
-static ParseResult_t ParseScript(mxml_node_t *scr, PrivateData_t *priv)
+static ParseResult_t ParseScript(xmlNode *scr, PrivateData_t *priv)
 {
     bool found = false;
-    mxml_node_t *act;
+    xmlNode *act;
     uint32_t actCnt;
     uint32_t i = 0;
     const char *txt;
@@ -1143,12 +1163,12 @@ static ParseResult_t ParseScript(mxml_node_t *scr, PrivateData_t *priv)
     assert(NULL != scr && NULL != priv);
     priv->scriptData.pause = 0;
     scrlist = priv->pScrLst;
-    if (!GetCountArray(scr->child, ALL_SCRIPTS, &actCnt, false)) RETURN_ASSERT(Parse_XmlError);
+    if (!GetCountArray(scr->children, ALL_SCRIPTS, &actCnt, false)) RETURN_ASSERT(Parse_XmlError);
     if (NULL == (script = MCalloc(&priv->objList, actCnt, sizeof(Ucs_Ns_Script_t))))
         RETURN_ASSERT(Parse_MemoryError);
     actCnt = 0;
     /*Iterate all actions*/
-    if (!GetElementArray(scr->child, ALL_SCRIPTS, &txt, &act)) RETURN_ASSERT(Parse_XmlError);
+    if (!GetElementArray(scr->children, ALL_SCRIPTS, &txt, &act)) RETURN_ASSERT(Parse_XmlError);
     while(act)
     {
         if (0 == strcmp(txt, SCRIPT_MSG_SEND)) {
@@ -1224,7 +1244,7 @@ static bool FillScriptInitialValues(Ucs_Ns_Script_t *scr, PrivateData_t *priv)
     return true;
 }
 
-static ParseResult_t ParseScriptMsgSend(mxml_node_t *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv)
+static ParseResult_t ParseScriptMsgSend(xmlNode *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv)
 {
     Ucs_Ns_ConfigMsg_t *req, *res;
     assert(NULL != act && NULL != scr && NULL != priv);
@@ -1254,7 +1274,7 @@ static ParseResult_t ParseScriptMsgSend(mxml_node_t *act, Ucs_Ns_Script_t *scr,
     return Parse_Success;
 }
 
-static ParseResult_t ParseScriptGpioPortCreate(mxml_node_t *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv)
+static ParseResult_t ParseScriptGpioPortCreate(xmlNode *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv)
 {
     uint16_t debounce;
     Ucs_Ns_ConfigMsg_t *req, *res;
@@ -1270,21 +1290,16 @@ static ParseResult_t ParseScriptGpioPortCreate(mxml_node_t *act, Ucs_Ns_Script_t
     req->OpCode = 0x2;
     res->OpCode = 0xC;
     req->DataLen = 3;
-    res->DataLen = 2;
+    res->DataLen = 0xFF; /* Using Wildcard */
     req->DataPtr = MCalloc(&priv->objList, req->DataLen, 1);
     if (NULL == req->DataPtr) return Parse_MemoryError;
-    res->DataPtr = MCalloc(&priv->objList, res->DataLen, 1);
-    if (NULL == res->DataPtr) return Parse_MemoryError;
     req->DataPtr[0] = 0; /*GPIO Port instance, always 0*/
     req->DataPtr[1] = MISC_HB(debounce);
     req->DataPtr[2] = MISC_LB(debounce);
-
-    res->DataPtr[0] = 0x1D;
-    res->DataPtr[1] = 0x00;
     return Parse_Success;
 }
 
-static ParseResult_t ParseScriptGpioPinMode(mxml_node_t *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv)
+static ParseResult_t ParseScriptGpioPinMode(xmlNode *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv)
 {
 #define PORT_HANDLE_OFFSET (2)
     uint8_t *payload;
@@ -1305,13 +1320,12 @@ static ParseResult_t ParseScriptGpioPinMode(mxml_node_t *act, Ucs_Ns_Script_t *s
     payload[0] = 0x1D;
     payload[1] = 0x00;
     req->DataPtr = payload;
-    res->DataPtr = payload;
     req->DataLen = payloadLen + PORT_HANDLE_OFFSET;
-    res->DataLen = payloadLen + PORT_HANDLE_OFFSET;
+    res->DataLen = 0xFF; /* Using Wildcard */
     return Parse_Success;
 }
 
-static ParseResult_t ParseScriptGpioPinState(mxml_node_t *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv)
+static ParseResult_t ParseScriptGpioPinState(xmlNode *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv)
 {
     uint16_t mask, data;
     Ucs_Ns_ConfigMsg_t *req, *res;
@@ -1329,24 +1343,19 @@ static ParseResult_t ParseScriptGpioPinState(mxml_node_t *act, Ucs_Ns_Script_t *
     req->OpCode = 0x2;
     res->OpCode = 0xC;
     req->DataLen = 6;
-    res->DataLen = 8;
+    res->DataLen = 0xFF; /* Using Wildcard */
     req->DataPtr = MCalloc(&priv->objList, req->DataLen, 1);
     if (NULL == req->DataPtr) return Parse_MemoryError;
-    res->DataPtr = MCalloc(&priv->objList, res->DataLen, 1);
-    if (NULL == res->DataPtr) return Parse_MemoryError;
     req->DataPtr[0] = 0x1D;
     req->DataPtr[1] = 0x00;
     req->DataPtr[2] = MISC_HB(mask);
     req->DataPtr[3] = MISC_LB(mask);
     req->DataPtr[4] = MISC_HB(data);
     req->DataPtr[5] = MISC_LB(data);
-    memcpy(res->DataPtr, req->DataPtr, req->DataLen);
-    res->DataPtr[6] = 0x00;
-    res->DataPtr[7] = 0x00;
     return Parse_Success;
 }
 
-static ParseResult_t ParseScriptPortCreate(mxml_node_t *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv)
+static ParseResult_t ParseScriptPortCreate(xmlNode *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv)
 {
     const char *txt;
     uint8_t speed;
@@ -1372,22 +1381,17 @@ static ParseResult_t ParseScriptPortCreate(mxml_node_t *act, Ucs_Ns_Script_t *sc
     req->OpCode = 0x2;
     res->OpCode = 0xC;
     req->DataLen = 4;
-    res->DataLen = 2;
+    res->DataLen = 0xFF; /* Using Wildcard */
     req->DataPtr = MCalloc(&priv->objList, req->DataLen, 1);
     if (NULL == req->DataPtr) return Parse_MemoryError;
-    res->DataPtr = MCalloc(&priv->objList, res->DataLen, 1);
-    if (NULL == res->DataPtr) return Parse_MemoryError;
     req->DataPtr[0] = 0x00; /* I2C Port Instance always 0 */
     req->DataPtr[1] = 0x00; /* I2C slave address, always 0, because we are Master */
     req->DataPtr[2] = 0x01; /* We are Master */
     req->DataPtr[3] = speed;
-
-    res->DataPtr[0] = 0x0F;
-    res->DataPtr[1] = 0x00;
     return Parse_Success;
 }
 
-static ParseResult_t ParseScriptPortWrite(mxml_node_t *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv)
+static ParseResult_t ParseScriptPortWrite(xmlNode *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv)
 {
 #define HEADER_OFFSET 8
     const char *txt;
@@ -1433,10 +1437,8 @@ static ParseResult_t ParseScriptPortWrite(mxml_node_t *act, Ucs_Ns_Script_t *scr
     req->OpCode = 0x2;
     res->OpCode = 0xC;
     req->DataLen = payloadLength + HEADER_OFFSET;
-    res->DataLen = 4;
+    res->DataLen = 0xFF; /* Using Wildcard */
     req->DataPtr = payload;
-    res->DataPtr = MCalloc(&priv->objList, res->DataLen, 1);
-    if (NULL == res->DataPtr) return Parse_MemoryError;
 
     req->DataPtr[0] = 0x0F;
     req->DataPtr[1] = 0x00;
@@ -1446,18 +1448,10 @@ static ParseResult_t ParseScriptPortWrite(mxml_node_t *act, Ucs_Ns_Script_t *scr
     req->DataPtr[5] = length;
     req->DataPtr[6] = MISC_HB(timeout);
     req->DataPtr[7] = MISC_LB(timeout);
-
-    res->DataPtr[0] = 0x0F;
-    res->DataPtr[1] = 0x00;
-    res->DataPtr[2] = address;
-    if (2 == mode)
-        res->DataPtr[3] = blockCount * length;
-    else
-        res->DataPtr[3] = length;
     return Parse_Success;
 }
 
-static ParseResult_t ParseScriptPortRead(mxml_node_t *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv)
+static ParseResult_t ParseScriptPortRead(xmlNode *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv)
 {
     uint8_t address, length;
     uint16_t timeout;
@@ -1478,11 +1472,9 @@ static ParseResult_t ParseScriptPortRead(mxml_node_t *act, Ucs_Ns_Script_t *scr,
     req->OpCode = 0x2;
     res->OpCode = 0xC;
     req->DataLen = 6;
-    res->DataLen = 4;
+    res->DataLen = 0xFF; /* Using Wildcard */
     req->DataPtr = MCalloc(&priv->objList, req->DataLen, 1);
     if (NULL == req->DataPtr) return Parse_MemoryError;
-    res->DataPtr = MCalloc(&priv->objList, res->DataLen, 1);
-    if (NULL == res->DataPtr) return Parse_MemoryError;
 
     req->DataPtr[0] = 0x0F;
     req->DataPtr[1] = 0x00;
@@ -1490,15 +1482,10 @@ static ParseResult_t ParseScriptPortRead(mxml_node_t *act, Ucs_Ns_Script_t *scr,
     req->DataPtr[3] = length;
     req->DataPtr[4] = MISC_HB(timeout);
     req->DataPtr[5] = MISC_LB(timeout);
-
-    res->DataPtr[0] = 0x0F;
-    res->DataPtr[1] = 0x00;
-    res->DataPtr[2] = address;
-    res->DataPtr[3] = length;
     return Parse_Success;
 }
 
-static ParseResult_t ParseScriptPause(mxml_node_t *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv)
+static ParseResult_t ParseScriptPause(xmlNode *act, Ucs_Ns_Script_t *scr, PrivateData_t *priv)
 {
     assert(NULL != act && NULL != priv);
     if (!GetUInt16(act, PAUSE_MS, &priv->scriptData.pause, true))
-- 
2.11.0.windows.3

